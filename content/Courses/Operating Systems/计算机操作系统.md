
> [!abstract] Course Information
> 课程通知：https://www.yuque.com/docs/share/7a7f9a35-5419-45c4-9b1b-138ae68bce06
> 课程索引：https://www.yuque.com/docs/share/a5cd1af5-3281-4d99-bbca-22037b946d9a#azopy
> 会议主题：操作系统课（2022秋）
> 会议时间：2022/09/14 09:50-12:15 (GMT+08:00) 中国标准时间 - 北京
> 重复周期：2022/09/14-2022/12/21 09:50-12:15, 每周 (周三)
> 入会链接：[https://meeting.tencent.com/dm/B5nGMq5g3UF8](https://meeting.tencent.com/dm/B5nGMq5g3UF8)
> 腾讯会议：400-7954-0041
> 会议密码：6221
> 老师：向勇、陈渝
## Labs
[[操作系统 实验 Lab1]]
[[操作系统 实验 Lab2]]
[[操作系统 实验 Lab3]]
[[操作系统 实验 Lab4]]
[[操作系统 实验 Lab5]]
[[操作系统 实验 Lab6]]

## Related Notes
[[ELF File Format]]

## Lectures
1. Lecture 1 @2022.09.14【第一讲，操作系统概述】✅
2. Lecture 2 @2022.09.21【第二讲，实验介绍】✅
3. Lecture 3 @2022.09.28 【第三讲，基于特权级的隔离与批处理】
4. Lecture 4 @2022.10.05【第四讲，多程序与愤世多任务
5. Lecture 5 @2022.10.12【第五讲，物理内存管理】
6. Lecture 6 @2022.10.19【第六讲，虚拟存储管理】
7. Lecture 7 @2022.10.26【第七讲，进程管理与单处理器调度】
8. Lecture 8 @2022.11.02【第八讲，多处理器调度】
9. Lecture 9 @2022.11.16【第九讲，文件系统】
10. Lecture 10 @2022.11.23 【第十讲，进程间通信】
11. Lecture 11 @2022.11.30【第十一讲，线程与协程】
12. Lecture 12 @2022.11.07【I/O设备管理】
13. Lecture 13 @2022.11.14【日志的文件系统】

## 基于特权级的隔离于批处理
> [!question] What is the difference between Interrupt, Exception, Faults, and Traps
- https://stackoverflow.com/questions/3149175/what-is-the-difference-between-trap-and-interrupt

> [!question] Process, Threads, and Couroutines

Process
Threads
- kernel threads
- user threads
Couroutines 
- green threads
- stackful coroutines
- stackless coroutines

> [!question] Context Switch



In computing, a context switch is the proces of storing the state of a process or thread,  so that it can be restored and resume execution at a later point, and then restoring a different, previously saved, state. This allows multiple processes to share a single CPU, and is an essential feature of a [multitasking operating system](https://en.wikipedia.org/wiki/Multitasking_operating_system "Multitasking operating system").




### Trapframe
https://xiayingp.gitbook.io/build_a_os/traps-and-interrupts/untitled-2


## 多道程序与分时多任务
## 物理内存管理
Good review on virtual memory and paging, https://courses.engr.illinois.edu/cs241/sp2014/lecture/09-VirtualMemory_II_sol.pdf
![](https://s2.loli.net/2023/02/02/f2BVtP5MDpAlbU9.png)

One level
![](https://s2.loli.net/2023/02/02/iwIRW3Ufg7OHE9r.png)

> [!question] 1 Level, 2 Level,  and Multi-Level Paging

Consider 32-bit virtual address (can be extended to 64-bit addresses), uses 4KB page sizes, and offset is 12 bits.

### Single-Level Paging
![](https://s2.loli.net/2022/11/08/B3Ivbn5jeKwNVrH.png)
Given a 32-bit virtual address space, we can have a total of 2^32 = 4GB address space. With a page size of 2^12 = 4KB, then we can easily see that the address space splits into 2^32 / 2^12 = 2^20 pages. This confirms our virtual address structure, page table index of 20 bits (can represent 2^20 pages), and offset is 12.

If we want to work backward, since our page table index is 20 bits, there can be 2^20 = 1048576 = 1MB pages. Since each page is 4KB in size, we can cover a virtual memory space of 1MB x 4KB = 4GB. 

How large are the entries? 
- Each entry contains a frame number. Since there are 2^32 physical addresses divided into frames of size 2^12 (assuming frame size == page size), we see that there are 2^20 frames, so we need 20 bits to store the frame number.
- Then we need some flag bits, such as **dirty bit** and **valid bit**, also for segmentation, we need **read, write, execute** permissible bits. 
This gives a total of 25 bits per entry. Lets round this up to 32 bits, or 4 bytes for easy math. Thus, the total size of the page table would be 2^20 entries x 2^2 bytes/entry = 2^22 = 4194304 = 4MB per table. 

![](https://s2.loli.net/2022/11/09/Hn87AhdUyFpqORJ.png)

4MB of contiguous space per process is a lot. Moreover, if the process is only using a small part of its address space, we will only need to access a small part of the page table. Just as with the address space, we can solve these problems by paging the page table itself. Lets look at double level paging.

### Double-Level Paging
![](https://s2.loli.net/2022/11/08/T5WJdY24MkpFXwg.png)

>[!info] In fact, 80x86 uses a two level paging system. Riscv also has SV32, which also uses a two level paging system

Compared to 1 one level paging system, now the translation to physical address takes 2 steps.
- The highest 10 bits is used as the index for the page directory table. 
- The next 10 bits is used as the index for the "page table" table. 
The page directory has 2^10 = 1024 = 1KB entries of length 4B per entry. The second table also contains 2^10 = 1K entries of length 4B per entry. Like above, each table entry (of the second table) contains a 20-bit address corresponding to our physical page frame. The figure below shows the transition process.

The 10-bit higher logical address is used to index the page directory table to get a pointer to the relevant second-level page table. The middle 10 digits of the virtual address are used to index the secondary page table to obtain a higher 20 digits of the physical address. The 12-bit offset of the virtual address is directly used as the lower 12-bit of the physical address, thus forming a complete 32-bit physical address.

![](https://s2.loli.net/2022/11/08/A9VrsQDx8HafOwg.png)


> [!question] Sv32 Virtural Addressing System

RISCV also has Sv32, a two stage address
https://www.cs.utexas.edu/~lorenzo/corsi/cs372/06F/hw/3sol.html



> [!question] Sv39 Virtual Address System

Good Source: https://osblog.stephenmarz.com/ch3.2.html
### Paging
Paging is a system by which a piece of hardware (commonly referred to as the Memory Management Unit or MMU) translates virtual addresses into physical addresses. The translation is performed by reading a privileged register called the SATP or Supervisor Address Translation and Protection register. This register turns the MMU on/off, sets the address space identifier, and sets the physical memory address where the first page table can be found.
We can place these tables anywhere in RAM provided the last 12 bits are 0. This is because the last 12 bits of the page table is not provided in the SATP. In fact, to get the actual memory address, we take 44 bits from the SATP and shift it left by 12 places, which replaces the last 12 bits with 0s. This forms a 56-bit bit address--not quite 64-bits.
### Virtual Addresses
The Sv39 virtual address contains three 9-bit indices. Since $2^9 = 512$ , each table contains exaclty 512 entries, and each entry is exactly 8-bytes (64-bits) as shown below. The Sv39 virtual address contains VPN[x]. The VPN stands for "virtual page number", which is essentially an index into an array of 512, 8 byte entries. So, instead of having the virtual address directly translate into a physical address, the MMU goes through a series of tables. With the Sv39 system, we can have one to three levels. Each level contains a table of 512, 8 byte entries.
![](https://s2.loli.net/2022/12/19/HCTMtOVfhjn7gK8.png)
### Table Entries
A table entry is written by the operating system to control how the MMU works. We can change how an address is translated or we can set certain bits to protect a page. 
![](https://s2.loli.net/2022/12/19/O4FzP9Wp3MXBQmx.png)
### Physical Address
The physical address is actually 56-bits. Therefore, a 39-bit virtual address can translate into a 56-bit physical address. Obviously, this allows us to map the same virtual address to a different physical address--much like how we will map addresses when creating user processes. The physical address is formed by taking PPN[2:0] and placing them into the following format. You will notice that the page offset is directly copied from the virtual address into the physical address.
![](https://s2.loli.net/2022/12/19/5CASLgEmcdKfhnH.png)
### SATP Register
All translations begin at the Supervisor Address Translation and Protection (SATP) register.
We can see that the PPN (physical page number) is a 44-bit value. However, this value has been shifted right by 12 bits before being stored. This essentially divides the actual number by 4096 ($2^{12}=4,096$). Therefore, the actual address is `PPN << 12`.

![](https://s2.loli.net/2022/12/19/DOYGT7Hl9EPFCkR.png)

Three Level
![](https://ucore-rv-64.github.io/uCore-RV-64-doc/_images/sv39-full.png)


### Page Faults
The MMU signals errors in translation to the CPU through three different page faults: 
1. instruction, 
2. load
3. store.
An instruction page fault occurs during the instruction fetch phase when the MMU throws a page fault. This can mean that the page entry is not valid or does not have the X (execute) bit set to 1 or some other reason.

Page faults are trapped by the CPU and the `mcause` or `scause` register will contain 12 for an instruction page fault, 13 for a load page fault, or 15 for a store page fault. The operating system can decide what to do then. In most cases, the correct response is to kill the offending process. However, there are some advanced systems, such as copy-on-write, that are implemented by trapping page faults. In these cases, a page fault is not a problem, it's a feature.
 

> [!question] Popular page replacement algorithm and belady's phenomenon

Why an algrotihm may suffer from belady: https://www.gatevidyalay.com/beladys-anomaly-page-fault-paging/
![](https://s2.loli.net/2022/11/08/iCe8sxNnfI3JZRm.png)

基本思路
- OPT -  replace page that will not be accessed for the most amount of time，swaps out the page whose next use will occur farthest in the future
- FIFO - replace the page that had been accessed earliest
- LRU - replace the page that had not been accessed for the longest period of time
- CLOCK - 

## 进程管理与单处理器调度
> [!abstract] 提纲
1. 进程管理 ❗
	1. 进程的基本概念
	2. 进程管理
	3. 关于Fork()的思考
		1. Fork()的开销
		2. 重新思考fork
2. 单处理器调度 ❗
	1. 处理机调度概念
		1. 处理机调度的时机和策略
		2. 比较调度算法的准则
	2. 调度算法
3. 实时调度 
	1. 实时操作系统 Real Time Operating System
		1. 实时操作系统的定义
		2. 试试任务
	2. 实时调度 
		1. 速率单调调度算法
		2. 最早截止时间优先算法
		3. 最低松弛度有限算法
	3. 优先级反置
		1. 优先级继承
		2. 优先级天花板协议
4. 实践：支持进程的操作系统 

> [!question] How to calculate fork counts?

In UNIX, 
1. kernel takes existing process and then copies all of it into another part of memory
2. creates kernel entries to support new process
3. gives control of cpu to user space in the new process
4. (optional) load an executable image into the process, overwriting the old process memory 
Process 1-3 are done by `fork()`, 4 is done by `exec()`
There is also something called `posix_spawn`, a lightweight version of `fork/exec`, which does not copy all of its memory

https://www.scaler.com/topics/operating-system/zombie-and-orphan-process-in-os/

> [!question] How does os pick the next process to run, and what are its characteristics?


Premptive Scheduling: 
Non-Premptive Scheduling:

Scheduling in Linux
- O(1) 
- CFS 
- BFS 
Characteristics to consider
- turnaround time - the time required for a particular process to complete, from submission time to completion, (waiting time + execution time)
- response time - the time taken in a program from the issuance of a command to the commence of a response to that command

## 文件系统
1. 文件和文件系统
2. 文件系统的设计与实现
3. 支持崩溃一致性的文件系统
4. 支持文件的操作系统
> [!question] What are superblocks, inodes?
- superblocks
- inodes
- root inode

## 进程间通信
1. 进程间通信IPC概述
	1. 进程间通信的概述
	2. 管道 pipe
	3. 消息队列 messag queue
	4. 共享内存 shared memory
	5. 信号 signal 
2. 支持IPC的OS
	1. 实验安排
	2. 代码结构
	3. 管道的设计实现
	4. 信号的设计实现
> [!question] What is IPC?
https://tldp.org/LDP/tlk/ipc/ipc.html



What is fd table




