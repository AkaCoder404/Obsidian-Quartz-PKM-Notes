# 实验5:内存串口实现
## Results
![](https://s2.loli.net/2023/02/02/iJfZxha92ApbRuq.png)
## Environment
Windows Virtual Machine on MAC
## Abstract
The goal of this experiment is to implement a MUX  master controller to control the wishbone mux. This is help us control the wishbone mux and thus the different devices connected to the bus. In addition to the SRAM controller from lab4, we are given an UART controller implementation, which handles transmission and receiving from the serial port. 

Our goal is to be able to read from the serial port with input `rxd` and write to serial port `txd`. We must send what we just read from the serial port to `txd`, as well as store what we read into sram memory.

The finite state machine logic is as such 

![](https://s2.loli.net/2023/02/02/lc8PRpr9LxoJhUn.png)

I used a 三段有限状态机. There are 10 states, and the logic is as such. (This is also the first two segments of the FSM)
```verilog
state_t state, next_state; // next_state;
// fsm switching logic
  always_ff @(posedge clk_i or posedge rst_i) begin
      if (rst_i) begin
          state <= STATE_IDLE;
      end else begin
          state <= next_state;    
      end
  end

always_comb begin
      case (state)
        STATE_IDLE:                   next_state = STATE_READ_WAIT_ACTION;
        STATE_READ_WAIT_ACTION: begin
          if (wb_ack_i)               next_state = STATE_READ_WAIT_CHECK;
          else                        next_state = STATE_READ_WAIT_ACTION;
        end

        STATE_READ_WAIT_CHECK: begin
          if (uart_state_reg[0])      next_state = STATE_READ_DATA_ACTION;
          else                        next_state = STATE_IDLE;
        end

        STATE_READ_DATA_ACTION: begin
          if (wb_ack_i)               next_state = STATE_READ_DATA_DONE;
          else                        next_state = STATE_READ_DATA_ACTION;
        end

        STATE_READ_DATA_DONE:         next_state = STATE_WRITE_SRAM_ACTION;
        STATE_WRITE_SRAM_ACTION: begin
          if (wb_ack_i)               next_state = STATE_WRITE_SRAM_DONE;
          else                        next_state = STATE_WRITE_SRAM_ACTION;
        end

        STATE_WRITE_SRAM_DONE:        next_state = STATE_WRITE_WAIT_ACTION;
        STATE_WRITE_WAIT_ACTION: begin
          if (wb_ack_i)               next_state = STATE_WRITE_WAIT_CHECK;
	      else                        next_state = STATE_WRITE_WAIT_ACTION;
        end

        STATE_WRITE_WAIT_CHECK: begin
          if (uart_state_reg[5])      next_state = STATE_WRITE_DATA_DONE;
          else                        next_state = STATE_WRITE_SRAM_DONE;
        end

        STATE_WRITE_DATA_DONE: begin
          if (wb_ack_i)               next_state = STATE_IDLE;
          else                        next_state = STATE_WRITE_DATA_DONE;
        end

        default:                      next_state = STATE_IDLE;
      endcase
  end
```

From `STATE_IDLE`, we set the address out to be 0x1000 0005, in order to read the status, we immediately move to the `STATE_READ_WAIT_ACTION` state, here we set the wait for the uart controller to send an ackowledgement that is ready to send. If we recieve an ack, then we get the data from the uart. Then we jump to `STATE_READ_WAIT_CHECK`, and it basically waits, and waits for the status, `uart_state_reg[0]` to be 1, which means that UART is able to send. Once UART is ready, to send, it goes to `READ_DATA_ACTION`, which reads the data when the master recieves an acknolwedgement. THen it moves onto DONE, and starts to write the data to SRAM. The process for writing back to UART Is similar.
## Experiment
The finite statemachine can be described above, and the specific signals is in the third segement of the finite state machine model
```verilog
always_ff @(posedge clk_i or posedge rst_i) begin
    if (rst_i) begin
      addr_reg <= init_addr;
    end else begin
      case(state)
        // Confirm if SERIAL port can be read
        STATE_IDLE: begin                    
          // addr_reg = init_addr;
          wb_adr_o <= 32'h10000005;                           // Ready to read uart status
          wb_cyc_o <= 1'b1;                                   // Clock input
          wb_stb_o <= 1'b1;                                   // Master wants to send request
          wb_we_o  <= 1'b0;                                   // Master sends request to read
          wb_sel_o <= 4'b0010;                                
        end

        // Wait for Serial Port to return address data
        STATE_READ_WAIT_ACTION: begin        
          if(wb_ack_i) begin                                 // If master recieves ack,
            uart_state_reg <= wb_dat_i[15:8];                // read state of uart 0x1000 0005
            wb_cyc_o <= 1'b0;                                 //
            wb_stb_o <= 1'b0;                                 //
            wb_sel_o <= 4'b0000;
          end
        end
        // Check uart status
        STATE_READ_WAIT_CHECK: begin        
          if (uart_state_reg[0]) begin                       // If 0x1000 0000 has value of 1, ready to receive
            wb_adr_o <= 32'h10000000;                         //      
            wb_cyc_o <= 1'b1;
            wb_stb_o <= 1'b1;
            wb_we_o  <= 1'b0;
            wb_sel_o <= 4'b0001;
            end
        end
        // Wait for Serial port to return data
        STATE_READ_DATA_ACTION: begin                      
          if(wb_ack_i) begin                                // If master recieves ack, read data
            wb_dat_i_reg <= wb_dat_i;
            wb_cyc_o <= 1'b0;
            wb_stb_o <= 1'b0;
            wb_sel_o <= 4'b0000;
          end
        end
        // Prepare to write to memory
        STATE_READ_DATA_DONE: begin          
          wb_adr_o <= addr_reg;
          wb_dat_o <= ({24'h0, wb_dat_i_reg[7:0]} << ((addr_reg%4)*8));  
          wb_sel_o <= (4'b0001 << (addr_reg%4));
          wb_cyc_o <= 1'b1;
          wb_stb_o <= 1'b1;
          wb_we_o  <= 1'b1;
        end
        // Wait for write to memory to finish
        STATE_WRITE_SRAM_ACTION: begin        
          if(wb_ack_i) begin
            wb_cyc_o <= 1'b0;
            wb_stb_o <= 1'b0;
            wb_we_o  <= 1'b0;
            wb_sel_o <= 4'b0000;
            addr_reg <= addr_reg + 4;                        // Increase address by 4 bytes every write
          end
        end
        // Prepare to write to serial port, first confirm if can
        STATE_WRITE_SRAM_DONE: begin        
          wb_adr_o <= 32'h10000005;                          // Prepare to read status again
          wb_cyc_o <= 1'b1;
          wb_stb_o <= 1'b1;
          wb_we_o  <= 1'b0;
          wb_sel_o <= 4'b0010;
        end

        // Wait for serial port to return data
        STATE_WRITE_WAIT_ACTION: begin      
          if(wb_ack_i) begin
            uart_state_reg <= wb_dat_i[15:8];
            wb_cyc_o <= 1'b0;
            wb_stb_o <= 1'b0;
            wb_sel_o <= 4'b0000;
          end
        end
        // Write to serial port
        STATE_WRITE_WAIT_CHECK: begin        
          if(uart_state_reg[5]) begin
            wb_adr_o <= 32'h10000000;
            wb_dat_o <= {24'h0, wb_dat_i_reg[7:0]};  
            wb_sel_o <= 4'b0001;
            wb_cyc_o <= 1'b1;
            wb_stb_o <= 1'b1;
            wb_we_o  <= 1'b1;
          end
        end
        // Process over, return to idle
        STATE_WRITE_DATA_DONE: begin          
          if(wb_ack_i) begin                                    // If Master recieve ack
            wb_cyc_o <= 1'b0;                                    //  
            wb_stb_o <= 1'b0;                                    // Master no longer wants to recieve
            wb_we_o  <= 1'b0;                                    //
            wb_sel_o <= 4'b0000;                                 //
          end
        end
      endcase
    end
  end
```

## Conclusion

Previously, I had trouble, with the address, and was confused why the data was not being stored in the sram. 
![](https://s2.loli.net/2023/02/02/ZXnJlN8uQikcGwr.png)
Then I realized that we had to initialize thestarting address, and that was set by the `dipsw` input. So I simply set the starting address when `rst_i` was 1.