
# 实验4:SRAM控制器
## Results
![](https://s2.loli.net/2023/02/02/dbXmcJIVneDlNLv.png)
## Environment
Windows Virtual Machine on Mac
## Abstract
The goal of this experiment is to implement a SRAM controller logic. Since there is only The SRAM controller logic is connected to the SRAM memory through one `inout` wire, it must use a finite state machine to properly handle read and write actions. It is important to note that reading and writing both take more than one step, reading takes two, while writing takes three, thus we must properly develop a finite state machine to tell the SRAM memory when we are reading from it, and when we are writing to it.

This chapter also introduces the Wishbone bus protocol and why designing a bus protocol is important. In short, it provides a unified hardware interface that allows the CPU core to access memory (SRAM) and external devices (UART). 
## Experiment

```verilog
module sram_controller #(
    parameter DATA_WIDTH = 32,
    parameter ADDR_WIDTH = 32,
    parameter SRAM_ADDR_WIDTH = 20,
    parameter SRAM_DATA_WIDTH = 32,
    localparam SRAM_BYTES = SRAM_DATA_WIDTH / 8;
    localparam SRAM_BYTE_WIDTH = $clog2(SRAM_BYTES)
) (

    // clk and reset
    input wire clk_i,
    input wire rst_i,
    // wishbone slave interface
    input wire wb_cyc_i,
    input wire wb_stb_i,
    output reg wb_ack_o,
    input wire [ADDR_WIDTH-1:0] wb_adr_i,
    input wire [DATA_WIDTH-1:0] wb_dat_i,
    output reg [DATA_WIDTH-1:0] wb_dat_o,
    input wire [DATA_WIDTH/8-1:0] wb_sel_i,
    input wire wb_we_i,
    // sram interface
    output reg [SRAM_ADDR_WIDTH-1:0] sram_addr,
    inout wire [SRAM_DATA_WIDTH-1:0] sram_data,
    output reg sram_ce_n,
    output reg sram_oe_n,
    output reg sram_we_n,
    output reg [SRAM_BYTES-1:0] sram_be_n
);

  // TODO: 实现 SRAM 控制器
  //tri-state logic for data input output
  wire [31:0] sram_data_i_comb;
  reg [31:0] sram_data_o_comb;
  reg sram_data_t_comb;
  assign sram_data = sram_data_t_comb ? 32'bz : sram_data_o_comb;
  assign sram_data_i_comb = sram_data;
 // 使用枚举定义状态列表，数据类型为 logic [2:0]
  typedef enum logic [2:0] {
    STATE_IDLE = 0,
    STATE_READ = 1,
    STATE_READ_2 = 2,
    STATE_WRITE = 3,
    STATE_WRITE_2 = 4,
    STATE_WRITE_3 = 5,
    STATE_DONE = 6
  } state_t;
  state_t state;  
  
  always_ff @(posedge clk_i, posedge rst_i) begin
    if (rst_i) begin
      state <= STATE_IDLE;
    end else begin
      case (state)
        STATE_IDLE: begin
          if (wb_stb_i && wb_cyc_i) begin
            if (wb_we_i)  state <= STATE_WRITE;
            else          state <= STATE_READ;
          end
        end
        STATE_READ:       state <= STATE_READ_2;
        STATE_READ_2:     state <= STATE_DONE;
        STATE_WRITE:      state <= STATE_WRITE_2;
        STATE_WRITE_2:    state <= STATE_WRITE_3;
        STATE_WRITE_3:    state <= STATE_DONE;
        STATE_DONE:       state <= STATE_IDLE;
        default:          state <= STATE_IDLE;
      endcase
    end
  end

  

  // 状态机逻辑

  always_comb begin

    wb_ack_o = 1'b0;
    sram_ce_n = 1'b1;                                          // disable sram chip
    sram_oe_n = 1'b1;                                            // disable read
    sram_we_n = 1'b1;                                            // disable write
    case (state)
        STATE_IDLE: begin
          // addr_reg = init_addr;
          wb_ack_o = 1'b0;
          sram_ce_n = 1'b1;                                            // disable sram chip
          sram_oe_n = 1'b1;                                            // disable read
          sram_we_n = 1'b1;                                            // disable write
        end

        STATE_READ: begin
          sram_data_t_comb = 1'b1;
          sram_addr = wb_adr_i[31:2];
          sram_be_n = ~wb_sel_i;
          sram_ce_n = 1'b0;                                          // enable sram chip
          sram_oe_n = 1'b0;                                          // enable read
          sram_we_n = 1'b1;                                          // disable write
        end

        STATE_READ_2: begin
          sram_data_t_comb = 1'b1;
          sram_addr = wb_adr_i[31:2];
          sram_be_n = ~wb_sel_i;
          wb_dat_o = sram_data_i_comb;
          sram_ce_n = 1'b0;                                         // enable sram chip
          sram_oe_n = 1'b0;                                         // enable read
          sram_we_n = 1'b1;                                         // disable write
        end

        STATE_WRITE: begin
          sram_data_t_comb = 1'b0;
          sram_addr = wb_adr_i[31:2];
          sram_data_o_comb = wb_dat_i;
          sram_be_n = ~wb_sel_i;                          
          sram_ce_n = 1'b0;                                         // enable sram chip
          sram_oe_n = 1'b1;                                         // disable read
          sram_we_n = 1'b1;      

        end

        STATE_WRITE_2: begin
          sram_data_t_comb = 1'b0;
          sram_addr = wb_adr_i[31:2];
          sram_data_o_comb = wb_dat_i;
          sram_be_n = ~wb_sel_i;
          sram_ce_n = 1'b0;                                         // enable sram chip
          sram_oe_n = 1'b1;                                         // disable read
          sram_we_n = 1'b0;                                         // enable write

        end

        STATE_WRITE_3: begin
          sram_data_t_comb = 1'b0;
          sram_addr = wb_adr_i[31:2];
          sram_data_o_comb = wb_dat_i;
          sram_be_n = ~wb_sel_i;
          sram_ce_n = 1'b0;                                         // enable sram chip
          sram_oe_n = 1'b1;                                         // disable read
          sram_we_n = 1'b1;                                         // disable write
        end

        STATE_DONE: begin
          sram_ce_n = 1'b1;                                         // disable sram chip
          sram_oe_n = 1'b1;                                         // disable read
          wb_ack_o = 1'b1;                                          // send ack
        end
    endcase
  end
endmodule
```
## Conclusion

### 思考题
1. 静态存储器的读和写有什么特点
Although DDR is usually used, SRAM is much more simpler in terms of implementation. SRAM offers better performance, because it does not need to be refreshed. It consumes less power, and has faster cycle time between accesses. But SRAM is also more expensive. 
2. 什么是RAM芯片输出的高阻态？他的作用是什么?
3 State logic allows input/output to assume high impedance state, which effectively removes the output from the circuit (as if it is not there). This is a third state, in addition to the 0, 1 logic state that a port can be.  This allows multiple circuits to share the same output line/lines. 
3. . 本实验完成的事Base_RAM和Ext_RAM作为独立的存储器单独进行访问的功能。如果希望将Base_RAM和Ext_RAM作为一个同一的64位数据的存储器进行访问，该如何进行。
We can simply treat the upper 32 bits as BASE_RAM, and the lower 32 bits as Ext_RAM, or the other way around.





