# 实验3: ALU与寄存器堆实验

## Results
![](https://s2.loli.net/2023/02/02/j8BcTYEa4VZyGrM.png)
## Environment
Windows in virtual machine on Mac M1
## Abstract
In the hardware design stage, simulation is a very import tool for debugging. This experiment aims to become more familiar with the process of simulation in Vivado. 

This also is our next step in our CPU, we have to implement the Arithmetic logic component ALU and the register heap RF. This in turns allows us to better understand both the various calculations and register heap logic of the ALU, as well as experience the design method of the finate state machine in SystemVerilog hardware description language.

## Experiment
This lab can be broken down into three parts: the controller, alu, and register file.
## Controller
Our controller has to handle two things, `r-type` and `i-type` commands. 

```cpp
// R-Type
// +------------+--------+--------+--------+-------+---------+-----+
// |   7bits    |  5bits |  5bits | 3bits  | 5bits |  4bits  |3bits|
// +------------+--------+--------+--------+-------+---------+-----+
// | 31      25 | 24  20 | 19  15 | 14  12 | 11  7 | 6     3 | 2 0 |
// +------------+--------+--------+--------+-------+---------+-----+
// |  0000000   |  rs2   |  rs1   |  000   |  rd   | op[3:0] | 001 |   
// +------------+--------+--------+--------+-------+---------+-----+

// +--------------+--------+-------+------+-----+
// | 31        16 | 15  12 | 11  7 | 6  3 | 2 0 |
// +--------------+--------+-------+------+-----+
// |   imm[15:0]  |  0000  |  rd   | 0001 | 010 |  I-Type POKE
// |   imm[15:0]  |  0000  |  rd   | 0010 | 010 |  I-Type PEEK
// +--------------+--------+-------+------+-----+

// POKE writes the 16 bit immediate number contained in the register imm into rd
// PEEK reads the 16 bit immediate number from rd and displays it on LED
```

The controller handles the core logic and data flow, which basically is a finite state machine, of which there are 5 states.
- STATE_INTIAL
- STATE_DECODE
- STATE_CALC
- STATE_READ_REG
- STATE_WRITE_REG

There are generally three types of FSM description methods, and the given example (in the documentation) discussed a one process FSM (一段式描述方法). There are also two process FSM (两段式描述方法) and three process (三段式描述方法). These finite machines can then be further labeled as Mealy and Moore. I chose to implement a three process FSM, which is show below. 

This can be split into three blocks. The first one controls the movement to the next state based on clock edge.
```verilog
    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= STATE_INIT;
        end else begin
            state <= next_state;    
        end
    end
```

The second is a combinational block, which sets the `next_state` to one of the 5 finite states.
```verilog
  always_comb begin    
        case(state)
            STATE_INIT:
                if (step)               next_state = STATE_DECODE;
                else                    next_state = STATE_INIT;
            STATE_DECODE: begin
                if (is_r_type_register) next_state = STATE_CALC;
                else if (is_peek)       next_state = STATE_READ_REG;
                else if (is_poke)       next_state = STATE_WRITE_REG;
                else                    next_state = STATE_INIT;
            end

            STATE_CALC:                 next_state = STATE_WRITE_REG;
            STATE_WRITE_REG:            next_state = STATE_INIT;
            STATE_READ_REG:             next_state = STATE_INIT;
            default:                    next_state = STATE_INIT;
        endcase
    end
```

The last block is also synchronous, handling all the wire assignments.
```verilog
always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            leds <= 16'b0;                                  // rst leds
            rf_we <= 1'b0;
            rf_raddr_a <= 5'b0;
            rf_raddr_b <= 5'b0;
            rf_waddr <= 5'b0;
            rf_wdata <= 16'b0;
            alu_a <= 16'b0;
            alu_b <= 16'b0;
            alu_op <= 4'b0;
        end else begin
            case (state)
                STATE_INIT: begin
                    rf_we <= 1'b0;                      // rst write_enable
                    instruction_registers <= dip_sw;    // wire signal input
                end

                STATE_DECODE: begin
                    if (is_r_type_register) begin
                        rf_raddr_a <= rs1;              // set read address to rs1
                        rf_raddr_b <= rs2;              // set read address to rs2
                    end else if (is_peek)  begin

                        rf_raddr_a <= rd;               // set read address to rd (read using rf_raddr_a) wire
                        rf_raddr_b <= 0;

                    end else if (is_poke) begin
                        rf_waddr <= rd;                 // set write address
                        rf_wdata <= imm;                // set write data to imm
                    end
                end

                STATE_CALC: begin
                    alu_a <= rf_rdata_a;                // wire signal to alu_a
                    alu_b <= rf_rdata_b;                // wire signal to alu_b
                    alu_op <= opcode;  

                end

                STATE_READ_REG: begin  
                    leds <= rf_rdata_a;        
                end

                STATE_WRITE_REG: begin
                    if (is_r_type_register) begin
                        rf_we <= 1'b1;
                        rf_waddr <= rd;
                        rf_wdata <= alu_y;
                    end else begin
                        rf_we <= 1'b1;                  // set write_enable to be true
                        rf_wdata <= imm;
                    end
                end
            endcase
        end
    end
```

Looking back at it, I believe two process FSM (combining the second and third block) would perhaps be better, or else there is a lot of repetative coding and might get more complicated if the FSM was more complicated.
## Register File

Based on the documentation, register reads are asynchronous while register writes are synchronous. Writing always implies that we want to store data into a memory element, and since memory elements are always composed of edge triggered flip  flops, thus are always done on clock edges. 

For reading, we implement combinational logic, while for writing we need a synchronous logic block. The module is defined in `rf.sv`

```verilog
module register_file (
    input wire clk,
    input wire rst,
    input wire [4:0] raddr_a,
    input wire [4:0] raddr_b,
    output reg [15:0] rdata_a,
    output reg [15:0] rdata_b,
    input wire [4:0] waddr,
    input wire [15:0] wdata,
    input wire we
);

    logic [15:0] regfile [0:31]; // 32 x 16 bit register file
    // don't allow read zero register, asynchronous reads
    assign rdata_a = (raddr_a == 5'd0) ? 16'd0 : regfile[raddr_a];
    assign rdata_b = (raddr_b == 5'd0) ? 16'd0 : regfile[raddr_b];

    integer i;
    always_ff @(posedge clk) begin
        // reset registers
        if (rst) begin
            for (i = 0; i < 32; i = i + 1) begin
                regfile[i] <= 0;
            end
        end else begin
            // if write enabled, write to register at waddr, except at x0
            if (we == 1'b1 & waddr != 5'd0) begin
                regfile[waddr] <= wdata;
            end
        end
    end
endmodule
```


## ALU

The ALU module itself uses combinational (non synchronous) logic. It uses simple `case` statement within an `always` block. The module is defined in `alu.sv` There were some trickeness with the shifting and rotating commands, but this ALU was relatively simple, as we did not have to account for overflow and such. 

```verilog
module alu (
    input wire [15:0] a,
    input wire [15:0] b,
    input wire [3:0] op,
    output reg [15:0] y

);

localparam
    ADD = 4'b0001,
    SUB = 4'b0010,
    AND = 4'b0011,
    OR  = 4'b0100,
    XOR = 4'b0101,
    NOT = 4'b0110,
    SSL = 4'b0111,
    SRL = 4'b1000,
    SRA = 4'b1001,
    ROL = 4'b1010;

always_comb @(*) begin
    case (op)
        ADD: y = a + b;
        SUB: y = a - b;
        AND: y = a & b;
        OR : y = a | b;
        XOR: y = a ^ b;
        NOT: y = ~a;
        SSL: y = a << (b % 16);
        SRL: y = a >> (b % 16);
        SRA: y = $signed(a) >>> (b % 16);
        ROL: y = (a << (b % 16)) | (a >> (16 - (b % 16)));
        default: y = 16'hFFFF;
    endcase
end

endmodule
```

# Simulation

I kept the current debugging setup described in `lab3_top_tb.sv` but added some more code to test the different functionalities of our design. 

FIrst, I added a for loop, I used an `ipeek` instruction to see the registers set by `ipoke`, which allows us to confirm what that ipoke set each register to be, much like the actual tests. We can see the results of `ipeek` by looking at the `leds` values. For example, using `$display`, I could easily see if my program was correct
```
Poke at register 01 with 6c77
Poke at register 02 with 1b20
Poke at register 03 with 0d52
Poke at register 04 with 2fa4
...
Peek at register 01 and got 6c77
Peek at register 02 and got 1b20
Peek at register 03 and got 0d52
Peek at register 04 and got 2fa4
...
```

After the for loop, storing a value at every, I then tested a couple of `rtype` commands, including `AND`, `OR`, and so on. And then I would peek at it. For example, 

```
91232 Testing ADD Function
Rtype 00000000001100010000000010001001 // reg[3] + reg[2] -> reg[1]
101434 Testing Peek after ADD
Peek 00000092 and got 2872

102636 Testing AND Function
Rtype 00000000001100010000000010011001 // reg[3] & reg[2] -> reg[1]
112838 Testing Peek after AND
Peek 00000092 and got 0900
```

## Summary
This experiment really helped improve test benching skills as well as getting more familiar with debugging with a hardware mindset, and how `always_comb` and `always_ff` really work. 

# Notes

Meally vs Moore 
- Meally is one cycle faster, because it uses current input and the current state to jdge
- Moore one more state, does not need current input  to judge, just current state

## Articles

Finite State Machines
- https://blog.csdn.net/wangkai_2019/article/details/107692192
- https://stackoverflow.com/questions/26618736/what-does-1-2-or-3-process-mean-for-an-fsm-in-

Register Read Files
- https://courses.cs.washington.edu/courses/cse370/10sp/pdfs/lectures/regfile.txt
- https://www.reddit.com/r/ECE/comments/gb7jvh/why_is_it_that_register_file_writes_are_performed/
- https://stackoverflow.com/questions/64431837/how-to-preset-the-register-arrays-in-verilog
- https://stackoverflow.com/questions/14130181/way-to-initialize-synthesizable-2d-array-with-constant-values-in-verilog

Latches (Inferring)
- https://stackoverflow.com/questions/22459413/what-is-inferred-latch-and-how-it-is-created-when-it-is-missing-else-statement-i
- https://stackoverflow.com/questions/20036401/if-statements-causing-latch-inference-in-verilog

Sequential Unused Error
- https://stackoverflow.com/questions/50676045/sequential-element-is-unused-and-will-be-removed-from-module-in-vivado

Set and Reset Error
- https://electronics.stackexchange.com/questions/361984/why-do-i-get-synth-8-5788-register-in-module-is-has-both-set-and-reset-with-s

SRA https://blog.csdn.net/adaliu1998/article/details/80459262

