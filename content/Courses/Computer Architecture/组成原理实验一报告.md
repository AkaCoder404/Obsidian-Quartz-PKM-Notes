# 实验 1：汇编语言与监控程序
<center> 计83 李天勤 2018080106 </center>
## Environment
I used the Parallels Virtual Environment on Mac M1 and ran Windows 11 to run the RISC-V cross compiler and UNIX simulation environment downloaded in `rv.zip`

## Abstract
This experiment was a good review of the RISCV instruction set architecture. I have also gotten a good understanding of the RISC-V Supervisor program, as well as the Term program and its commands, as well as the overall structure of the environment

## Experiment
### Fibonacci Sequence First 10
Since at first, I did not have a strong understanding of the RISCV instruction architecture set and a good understanding of how to implement the correct logic flow, I first implemented it in C, then translated it to the corresponding 
![](https://s2.loli.net/2023/02/02/Oshp9zi12eXCWyl.png)

The logic is quite simple, but instead of allocating 10 contiguous 32 bit memory location in a random location, we have to output the results into the user code data stack starting at `0x80400000` when working in our RISCV CPU. 

I used the file function of `Term`, which first loads the user program to a specified address. According to documentation, we load this at `0x801000000`
```
>> f
>> file name: fib.S
addr: 0x80100000
>> g
addr: 0x80100000
...
```

The code is as such
![](https://s2.loli.net/2023/02/02/YFnqdxohAOMB5eb.png)
First we load the program. 
![](https://s2.loli.net/2023/02/02/tsyGMm91PxBJqNh.png)

Then we run the program using `g`
![](https://s2.loli.net/2023/02/02/8Ns4neUPZwEazWr.png)


Then we check the data stack using `d`
![](https://s2.loli.net/2023/02/02/f9jcbZG5To8FPAR.png)

Comparing this to the ouptut of the C code, it can be shown that our program is correct
![](https://s2.loli.net/2023/02/02/INSpgiFuBtQwToa.png)

In order to restrict my assembly program to use only the 19 RISCV instrucions supported by the supervisor, I changed some parts of the code. 
![](https://s2.loli.net/2023/02/02/Z9oEadzeFUAW4VH.png)
It is essentially the same, but replacing `li` instruction with `lui` and `addi`, I also removed the `j` instruction. I also realized the if we run the program multiple times, the stored data at the current location still persists, so thus we must clear it before running it (or restart the kernel and term), I think we have to consider this later on, but for simplicity I omitted it from the code.
### ASCII Characters
![](https://s2.loli.net/2023/02/02/XmNxhuMFQzelf2S.png)
The logic of this part was easier to implement as we were given how to write to the `Term` window using `WRITE_SERIAL`. We load what we want to write to the register `a0`, and write the byte to the location `0x10000000` which is reserved for the serial port, or input/output. Before writing however, it makes sure that the serial port is unused. 

Another important thing is to allow interrupts and syscalls to allow writing to serial port, which can be allowed by slightly changing `编译Kernel并启动模拟器.cmd`

![](https://s2.loli.net/2023/02/02/uRV1yi3XJLwNY2n.png)

And we run using the file option, with the following output.
![](https://s2.loli.net/2023/02/02/7FJjWax4HvTuegb.png)

It is consistent with the table below, thus our program is correct.
![](https://s2.loli.net/2023/02/02/7sgoR1tb3Lm9wUI.png)
Like above, I removed `li` from my instruction set, and change `bgt` to `bne`
![](https://s2.loli.net/2023/02/02/fZzDmTpneEhCLt1.png)

There was also an error in the output above, I thought it was due to the destruction of `ra` register during the call of `jal`, since `ra` is a caller-saved register, so I saved it to the stack, and restored it after. The modified coed is as such.
![](https://s2.loli.net/2023/02/02/rJCx2A6gBhIQD58.png)

However, I still had the same error. I was confused on how to solve this.
### 60th Fibonacci Sequence Number
The Fibonacci sequence grows quite fast, and soon, the integer becomes too big to store in a 32bit memory address, which has a maximum of 4,294,967,295. 
We can see how the sequence grows. 
```
n  : Fn
0  : 0
1  : 1
2  : 1
3  : 2
4  : 3
5  : 5
...
30 : 832,040
31 : 1,346,269
...
46 : 1,836,311,903
47 : 2,971,215,073
48 : 4,807,526,976
...
60 : 1,548,008,755,920
```

We can see that by the 48th number in the sequence, it exceeds the amount of space we currently have. Thus, as the prompt suggest, we have to store the number in two locations, `0x80400000` for the lower 32 bits, and `0x80400004` for the upper 32 bits.

My algorithm is based of that of algorithm precision arithmetic found [here](https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic). I first implemented in C to make sure it works. 
![](https://s2.loli.net/2023/02/02/DtbRlUnr8AHIZgW.png)

Then in assembly, 
![](https://s2.loli.net/2023/02/02/5cqYJC3lz9uQhAf.png)

Running it we get 
![](https://s2.loli.net/2023/02/02/zcKVIJls6LohRTp.png)

Thus giving us 0x1686c8312d0, or 1548008755920 as our 60th Fibonacii number, which is consistent with our C program. 
![](https://s2.loli.net/2023/02/02/jL7ptkIWiNOJq3G.png)

## Conclusion 
### 比较 RISC-V 指令寻址方法与 x86 指令寻址方法的异同。
1. The RISCV architecture has simple instructions that can be executed in a single computer clock cycle. As a result, the completion of a specific task often requires the execution of multiple instructions. That same task can be completed with fewer instructions on CISC processor, but may take multiple clock cycles to complete. RISC may take more cycles for the same task, but is also more efficient.
2. The RISCV architecture uses a load-store topology, which means that it cannot directly operate on data in memory, instead, requiring the user to move data from memory to its internal registers before it can operate on them. This may make RISC-V slower than CISC in this case, but it allows for much simpler hardware design, and therefore with less silicon.
3. On the other hand, x86, is a register-memory architecture, which means that it can operate on or from memory, and registers, or in combinations.
### 阅读监控程序，列出监控程序的 19 条指令，请根据自己的理解对用到的指令进行分类，并说明分类原因。（参考 README.md）
```python
ADD   0000000SSSSSsssss000ddddd0110011 # 
ADDI  iiiiiiiiiiiisssss000ddddd0010011 # 
AND   0000000SSSSSsssss111ddddd0110011 # 
ANDI  iiiiiiiiiiiisssss111ddddd0010011 # 
AUIPC iiiiiiiiiiiiiiiiiiiiddddd0010111 #
BEQ   iiiiiiiSSSSSsssss000iiiii1100011 #
BNE   iiiiiiiSSSSSsssss001iiiii1100011 #
JAL   iiiiiiiiiiiiiiiiiiiiddddd1101111 #
JALR  iiiiiiiiiiiisssss000ddddd1100111 # 
LB    iiiiiiiiiiiisssss000ddddd0000011 # 
LUI   iiiiiiiiiiiiiiiiiiiiddddd0110111 # 
LW    iiiiiiiiiiiisssss010ddddd0000011 #
OR    0000000SSSSSsssss110ddddd0110011 #
ORI   iiiiiiiiiiiisssss110ddddd0010011 #
SB    iiiiiiiSSSSSsssss000iiiii0100011 #
SLLI  0000000iiiiisssss001ddddd0010011 # 
SRLI  0000000iiiiisssss101ddddd0010011 # 
SW    iiiiiiiSSSSSsssss010iiiii0100011 #
XOR   0000000SSSSSsssss100ddddd0110011 # 
```
I would categorize the instructions as such based on each of their functionality.
<center> <h3> Arithmetic Instructions </h3> </center>
| Mnmonic             | Instruction          | Type | Description       |
|---------------------|----------------------|------|-------------------|
| ADD rd, rs1, rs2    | Add                  | R    | rd <- rs1 + rs2   |
| ADDI rd, rs1, imm12 | Add immediate        | I    | rd <- rs1 + imm12 |
| LUI rd, imm12       | Load upper immediate | U    | rd <- imm20 << 12 |
| AUIPC rd, imm20     | Add upper immediate to PC | U | rd <- PC + imm20 << 12 |
<center> <h3> Logical Operations </h3> </center>
| Mnmonic             | Instruction                   | Type | Description        |
|---------------------|-------------------------------|------|--------------------|
| AND rd, rs1, rs2    | AND                           | R    | rd <- rs1 & rs2    |
| ANDI rd, rs1, imm12 | AND Immediate                 | I    | rd <- rs1 & imm12  |
| XOR rd, rs1, rs2    | XOR                           | R    | rd <- rs1 ^ rs2    |
| XORI rd, rs1, imm12 | XOR Immediate                 | I    | rd <- rs1 ^ imm12  |
| SLLI rd, rs1, shamt | Shfit left logical immediate  | I    | rd <- rs1 << shamt |
| SRLI rd, rs1, shamt | Shift right logical immediate | I    | rd <- rs1 >> shamt |

<center> <h3> Load/Store Operations </h3></center>
| Mnmonic             | Instruction                   | Type | Description        |
|---------------------|-------------------------------|------|--------------------|
| AND rd, rs1, rs2    | AND                           | R    | rd <- rs1 & rs2    |
| ANDI rd, rs1, imm12 | AND Immediate                 | I    | rd <- rs1 & imm12  |
| XOR rd, rs1, rs2    | XOR                           | R    | rd <- rs1 ^ rs2    |
| SLLI rd, rs1, shamt | Shfit left logical immediate  | I    | rd <- rs1 << shamt |
| SRLI rd, rs1, shamt | Shift right logical immediate | I    | rd <- rs1 >> shamt |
<center> <h3> Branching Operations </h3> </center>
| Mnmonic             | Instruction            | Type | Description                       |
|---------------------|------------------------|------|-----------------------------------|
| BEQ rs1, rs2, imm12 | Branch equal           | SB   | if rs1 == rs2    pc <- pc + imm12 |
| BNE rs1, rs2, imm12 | Branch not equal       | SB   | if rs1 != rs2    pc <- pc + imm12 |
| JAL rd, imm20       | Jump and link          | UJ   | rd <- pc + 4 pc <- pc + imm20     |
| JALR rd, imm12(rs1) | Jump and link register | I    | rd <- pc + 4 pc <- rs1 + imm12    |

### 结合 term 源代码和 kernel 源代码说明 term 是如何实现用户程序计时的。
In term.py, simply use `timer()`, to record start, end, and time lapse is the difference between the too.
![](https://s2.loli.net/2023/02/02/xpJ2usYXzDMFciQ.png)
In Kernel, this enables machine-mode/kernel mode timer interrupts, which I believe is effectively the timer.
![](https://s2.loli.net/2023/02/02/THbf4o2d1O7SFw9.png)
But to handle user mode, it should be found in `shell.S`,

![](https://s2.loli.net/2023/02/02/SEwNQzBy7DnJ9Yd.png)

### 说明 kernel 是如何使用串口的（在源代码中，这部分有针对 FPGA 与 QEMU 两个版本的代码，任选其一进行分析即可）。
Here, we see the kernel enable and config the 串口, found in `init.S`
![](https://s2.loli.net/2023/02/02/AZwOoNxupR6eDUT.png)

Based on the readme, the serial port data and status is configured to the address at `0x10000000`, and is set up based on Serial UART, a universal asynchronous receiver / transmitter responsible for performing serial communications with computers.
![](https://s2.loli.net/2023/02/02/24h8DyIuazsxgfk.png)

### 请问 term 如何检查 kernel 已经正确连入，并分别指出检查代码在 term 与 kernel 源码中的位置。

After Kernel boots from `0x80000000`, it first outputs the Kernel version, as we see when running `编译Kernel并启动模拟器.cmd` and booting our Kernel, and then launching `term`, we can see that it is conneceted correctly.
![](https://s2.loli.net/2023/02/02/2woPp1UJgKEsXMn.png)

After Kernel runs, it outputs the version number through the serial port, which can be used as a sign to verify its normal operation. Kernel will then wait for Term to send the command from the serial port. 

Then we execute `python term.py -t 127.0.0.1:6666` to connect to our lab platform, ThinPad or QEMU,  where `-t` defines the target IP and Port number. 

First, `Term` checks for these two things
![](https://s2.loli.net/2023/02/02/zj9vptDPqsKTI2X.png)

If `Kernel` is not running, or the incorrect address is set, then it will produce the error 'Failed to establish TCP connection'. 

Then it runs `test_programs()` to check if the environment has the necessary conditions. After, it will show a connected status and output
```
running in 32bit, xlen = 4
```

And then we can run our commands as normal.

In the Kernel, the codes are located in its assembly files, specifically `init.S`. First its sets up the environment, like bss, kernel stack user stack, etc, then it eventuall sets up the serial port, and welcomes it once term connects to kernel.
![](https://s2.loli.net/2023/02/02/C3iWeTSrYJLIKtG.png)
