# 实验6: 处理器实验
## Results
The results from the cloud platform are the same as the expected results
![](https://s2.loli.net/2022/11/20/sbXyVWwlN1uri2R.png)

![](https://s2.loli.net/2022/11/20/MzBW7OhbP1KFQV2.png)

![](https://s2.loli.net/2022/11/20/VH6csbiJ8zTl3OR.png)
## Environment
Windows in virtual machine on Mac M1
## Abstract
The purpose of this experiment is to implement either a multi-cycle or five-level pipeline processor capable of running the monitor program (given assembly program), that can support a few instructions, and see the output effect from the serial port.  After the program code is compiled to generate a binary file, it is loaded into BaseRam. At startup, the program is executed from the starting address of BaseRam, and the reset key is pressed to start running from `0x8000_0000` , where the first instruction of the program is.
## Experiment
### 项目主要目录
```
cod22-litq18/
├─ thinpad_top.srcs/ 
│  ├─ sources_1/
│  │  ├─ new/
│  │  │  ├─ lab6/
│  │  │  │  ├─ lab6_top.sv            
│  │  │  │  ├─ cpu_master.sv
│  │  │  │  ├─ rf.sv
│  │  │  │  ├─ sram_controller
│  │  │  │  ├─ uart_controller
│  │  │  │  ├─ wb_mux_3.v
│  │  │  │  ├─ alu.sv
│  ├─ sims_1/
│  │  ├─ new/
│  │  │  ├─ tb/
│  │  │  │  ├─ lab6_tb.sv
├─ tmp/ 
│  │  ├─ lab6.bin
│  │  ├─ kernel.elf
```

Our core code is in `cpu_master.sv` which contains the controller logic for our cpu. However, we have to slightly change previously defined `rf.sv` and `alu.sv` to handle 32bit values/registers, while in previous labs, we only had to handle 16bit.

### 指令集，信号表，和状态转移表
I have implemented a 多周期 CPU, and below is the definitions for each of the instruction, and its transitions on our five stage finite state machine. Our finite state machine contains 5 steps: STATE_IF, STATE_ID, STATE_EXE, STATE_MEM, STATE_WB. 

需要实现的指令包含
LUI, BEQ, LB, SB, SW, ADDI, ANDI, ADD

#### LUI (utype instruction)
```cpp
LUI rd, U_imm
opcode = 7'b011_0111
// writes imm[31:12] to the upper 20 bits of rd, and the lower 12 bits of rd will be filled with zero
```
lui指令功能描述
1. 将寄存器指令的一部分翻译成立即数
2. 将立即数存入到rd
控制信号设计
1. STATE_IF：从SRAM中读取指令
2. STATE_ID：从寄存器中读取对应的值，同时生成立即数
3. STATE_EXE：做运算
4. STATE_MEM：从SRAM中读取数值
5. STATE_WB：写入到寄存器，pc加4，更新pc
![](https://s2.loli.net/2023/02/02/Ncf8YUHKCW2b5PV.png)

#### BEQ (btype instruction)
```cpp
BEQ rs1, rs2, label //imm
opcode = 7b'110_0111
funct3 = 3'b000
// imm is a 12 bit immediate, which is an integer multiple of 2, sign extended to 32bits
// if rs1==rs2, jump offset is PC+imm, and the jump range is +-4K, and must jump in steps of 2
// note that there is no rd, so the instruction does not record the current PC val before jumping, so we have to save that ourselves.
```
beq指令功能描述
1. 从寄存器中读取rs1，rs2对应的数值
2. 将寄存器指令的一部分翻译成立即数，并做符号扩展
3. 算pc和立即数的相加
4. 将上述rs1和rs2做对比，如果相等，pc等上述结果
5. 如果不想等，pc加四
控制信号设计
1. STATE_IF：从SRAM中读取指令
2. STATE_ID：从寄存器中读取对应的值，x同时生成立即数
3. STATE_EXE：做运算，相等/不想等
4. STATE_MEM：无
5. STATE_WB：无
#### LB (itype instruction)
```cpp
LB rd, offset(rs1）
offset = imm[11:0]
opcode = 7'b000_0011
funct3 = 3'b000
// read a copy of 8 bit data from memory, after sign bit extension, store in rd register
```
lb指令功能描述
1. 从寄存器中读出rs1对应的数值
2. 将寄存器指令的一部分翻译成立即数，并做符号扩展
3. 将上述两个结果相加
4. 将结果低8bit存入到rd
控制信号设计
1. STATE_IF：从SRAM中读取指令
2. STATE_ID：生成立即数
3. STATE_EXE：做运算
4. STATE_MEM：从SRAM中读取
5. STATE_WB：写入到寄存器，pc加4，更新pc

![](https://s2.loli.net/2022/11/20/jpnEFRUXOhyVezZ.png)

#### SB (stype instruction)
```cpp
SB rs2， offset(rs1)
offset = imm[11:0]
opcode = 7'b010_0011
funct3 = 3'b000
// copy the value of the lower 8 bits of rs2 to the memory
```
sb指令功能描述
1. 从寄存器中读出rs1，rs2对应的数值
3. 将指令的一部分翻译成立即数，并做符号扩展
4. 将上述rs1和立即数两个结果相加
5. 将rs2对应值的低8bits存入到SRAM中的上述结果的位置
控制信号设计
1. STATE_IF：从SRAM中读取指令
2. STATE_ID：从寄存器中读取对应的值，同时生成立即数
3. STATE_EXE：做运算
4. STATE_MEM：寄存器中对应的rs2（低八位）值写入到SRAM中
5. STATE_WB：pc加4，能信pc
![](https://s2.loli.net/2023/02/02/ZEF5HuSKxYyQhTU.png)

#### SW (stype instruction)
```cpp
SW rs2, offset(rs1)
offset = imm[11:0] 
opcode = 7'b010_0011
funct3 = 3'b010
// copy the value of rs2 to memory
```
sw指令功能描述
1. 从寄存器中读出rs1, rs2对应的数值
2. 将指令的一部分翻译成立即数，并做符号扩展
3. 将上述rs1和立即数两个结果相加
4. 将rs2对应的值存入到SRAM中的上述结果的位置
控制信号设计
1. STATE_IF：从SRAM中读取指令
2. STATE_ID：从寄存器中读取对应的值，同时生成立即数
3. STATE_EXE：做运算
4. STATE_MEM：寄存器中对应的rs2值写入到SRAM中
6. STATE_WB：pc加4，能信pc
![](https://s2.loli.net/2022/11/20/zNPT7An1iqZ5M4d.png)


#### ADDI (itype instruction)
```cpp
ADDI rd, rs1, imm[11:0]
opcode = 7'b001_0011
funct3 = 3'b000
// adds value of rs1 to immediate, and stores result in rd
```

addi指令功能描述
1. 从寄存器中读出rs1对应的数值
2. 将指令的一部分翻译成立即数。并做符号扩展
3. 将上述两个结果相加
4. 将结果存入rd对应的寄存器中
控制信号设计
1. STATE_IF: 从SRAM中读取指令
2. STATE_ID：从寄存器中读取对应寄存器的值，同时生成立即数
3. STATE_EXE: 做运算
4. STATE_MEM: 无
5. STATE_WB: 将结果写到寄存器，pc加4，跟新pc

![](https://s2.loli.net/2022/11/20/bvGszK1e2RQYqOr.png)

![](https://s2.loli.net/2022/11/20/JcD4pmr1WXolnZM.png)
#### ANDI (itype instruction)
```cpp
ANDI rd, rs1, imm[11:0] 
opcode = 7'b001_0011
funct3 = 3'b000
// the immediate is expanded to 32 bits as signed number, then perform AND wirth rs1, and store result in rd
```

andi指令功能描述
1. 从寄存器中读出rs1对应的数值
2. 将指令的一部分翻译成立即数。并做符号扩展
3. 将上述两个结果AND
4. 将结果存入rd对应的寄存器中
控制信号设计
1. STATE_IF：从SRAM中读取指令
2. STATE_ID：从寄存器中读取对应的值，同时生成立即数
3. STATE_EXE：做运算
4. STATE_MEM：无
5. STATE_WB：将结果写到寄存器，pc加4，更新pc
![](https://s2.loli.net/2022/11/20/bn8q3dpJBoULePR.png)

#### ADD (rtype instruction)
```cpp
ADD rd, rs1, rs2
opcode = 7'b011_0011
funct7 = 7'b000_0000
funct3 = 3'b000
// writes the result of rs1 + rs2 into rd, ignoring overflow, overflow handled by software
```
add指令功能描述
1. 从寄存器中读出rs1和rs2对应的数值
2. 将上述两个结果想加
3. 将结果存入rd对应的寄存器中
控制信号设计
1. STATE_IF：从SRAM中读取指令
2. STATE_ID：从寄存器中读取对应的值，同时生成立即数
3. STATE_EXE：做运算
4. STATE_MEM：无
5. STATE_WB：将结果写入寄存器，pc加4，更新pc
![](https://s2.loli.net/2022/11/20/nq5Mc9kwaDW4slv.png)
### CPU 的结构图




### 代码
Based on the design and control flow described above, here is the structure of the code. I used a three process finite state machine. 
The first segment drives the transition to the next stage
```verilog
always_ff @(posedge clk_i or posedge rst_i) begin
	if (rst_i) begin
		state <= STATE_IF;
	end else begin
		state <= next_state;
	end
end
```
The second segment defines the transitions.
```verilog
always_comb begin
        case (state)
            STATE_IF: begin
                if (wb_ack_i)                   next_state = STATE_ID;
                else                            next_state = STATE_IF;
            end
            STATE_ID: begin
                if (is_r_type_register) begin end
                else if (is_i_type_register) begin
                    if (is_addi);
                    else if(is_andi);
                    else if (is_lb)             next_state = STATE_MEM;
                end
                else if (is_s_type_register) begin end
                else if (is_b_type_register) begin end
                else if (is_u_type_register) begin end
                else begin
                                                next_state = STATE_EXE;
                end
                next_state = STATE_EXE;
            end
            STATE_EXE: begin
                if (is_add)                     next_state = STATE_WB;
                else if (is_addi)               next_state = STATE_WB;
                else if (is_andi)               next_state = STATE_WB;
                else if (is_s_type_register) begin
                    if (is_sb);
                    else;
                                                next_state = STATE_MEM;
                end
                else if (is_lb)                 next_state = STATE_MEM;
                else if (is_beq)                next_state = STATE_IF;
                else if (is_lui)                next_state = STATE_WB;
                else                            next_state = STATE_EXE;
            end
            STATE_MEM: begin
                if (wb_ack_i)                   next_state = STATE_WB;
                else                            next_state = STATE_MEM;
            end
            STATE_WB: begin
                                                next_state = STATE_IF;
            end
            default: begin
                                                // do nothing
            end

        endcase

    end
```

The third segment defines the control signals
```verilog
always_ff @(posedge clk_i) begin
        if (rst_i) begin
            pc_reg          <= 32'h8000_0000;
            instr_reg       <= 32'h0000_0000;  
            rf_we           <= 1'b0;    // register file turn off write
            wb_cyc_o        <= 1'b0;    // turn off wishbone
            wb_stb_o        <= 1'b0;    //
            wb_we_o         <= 1'b0;
        end else begin
            case (state)
                STATE_IF: begin
                    if(wb_ack_i) begin
                        instr_reg   <= wb_dat_i;
                        wb_cyc_o    <= 1'b0;
                        wb_stb_o    <= 1'b0;
                    end else begin
                        wb_adr_o    <= pc_reg;
                        wb_cyc_o    <= 1'b1;
                        wb_stb_o    <= 1'b1;
                        wb_sel_o    <= 4'b1111;
                    end
                end
                STATE_ID: begin
                    if(is_r_type_register) begin
                        alu_a_o <= rf_rdata_a;
                        alu_b_o <= rf_rdata_b;
                        if(is_add) begin
                            alu_op_o <= ADD;
                        end
                    end
                    else if(is_i_type_register) begin
                        alu_a_o <= rf_rdata_a;
                        alu_b_o <= imm_gen_instr;
                        if(is_addi) begin
                            alu_op_o <= ADD;
                        end
                        else if(is_andi) begin
                            alu_op_o <= AND;
                        end
                        else if(is_lb) begin
                            alu_op_o <= ADD;
                        end
                    end
                    else if(is_s_type_register) begin
                        alu_a_o <= rf_rdata_a;
                        alu_b_o <= imm_gen_instr;
                        alu_op_o <= ADD;
                    end

                    else if(is_b_type_register) begin
                        alu_a_o <= pc_reg;
                        alu_b_o <= imm_gen_instr;
                        alu_op_o <= ADD;
                    end
                    else if(is_u_type_register) begin
                        alu_op_o <= ADD;
                    end
                end
                STATE_EXE: begin
                    if(is_add) begin
                        rf_waddr <= rd;
                        rf_wdata <= alu_y_i;
                        rf_we <= 1'b1;
                    end else if (is_addi) begin
                        rf_waddr <= rd;
                        rf_wdata <= alu_y_i;
                        rf_we <= 1'b1;
                    end else if (is_andi) begin
                        rf_waddr <= rd;
                        rf_wdata <= alu_y_i;
                        rf_we <= 1'b1;
                    end
                    else if(is_s_type_register) begin
                        wb_cyc_o <= 1'b1;
                        wb_stb_o <= 1'b1;
                        wb_adr_o <= alu_y_i;
                        if(is_sb) begin
                            wb_dat_o <= (rf_rdata_b[7:0] << ((alu_y_i % 4) * 8));
                            wb_sel_o <= (4'b0001 << (alu_y_i % 4))
                        end else begin
                            wb_dat_o <= rf_rdata_b;
                            wb_sel_o <= 4'b1111;
                        end
                        wb_we_o <= 1'b1;
                    end
                    else if(is_lb) begin
                        wb_cyc_o <= 1'b1;
                        wb_stb_o <= 1'b1;
                        wb_adr_o <= alu_y_i;
                        wb_sel_o <= (4'b0001 << (alu_y_i % 4));
                    end
                    else if(is_beq) begin
                        if(rf_rdata_a == rf_rdata_b)
                            pc_reg <= alu_y_i;
                        else
                            pc_reg <= pc_reg + 32'h4;
                    end
                    else if(is_lui) begin
                        rf_waddr <= rd;
                        rf_wdata <= imm_gen_instr;
                        rf_we <= 1'b1;
                    end
                end
                STATE_MEM: begin
                     if(wb_ack_i) begin
                        wb_cyc_o <= 1'b0;
                        wb_stb_o <= 1'b0;
                        wb_sel_o <= 4'b0000;
                        wb_we_o <= 1'b0;
                        if(is_lb) begin
                            rf_waddr <= rd;
                            rf_wdata <= 32'h0000_00ff & (wb_dat_i >> ((wb_adr_o % 4) * 8));
                            rf_we <= 1'b1;
                        end else begin
                            rf_we <= 1'b0;
                        end
                     end
                end
                STATE_WB: begin
                    rf_we <= 1'b0;
                    pc_reg <= pc_reg + 32'h4;
                end
            endcase
        end
```


## Conclusion
### 思考题
1. 流水线 CPU 中，用于 branch 指令的比较器既可以放在 ID 阶段，也可以放在 EXE 阶段。放在这两个阶段分别有什么优缺点？
Data hazards occur in pipelined CPUs if some instructions depend upon others that are still expecting. Although many hazards can be resolved by forwarding data from the pipeline registers, instead of waiting for writeback stage. But fowarding may not work for data hazards from load instructions. 

Branches can affect the instruction fetch for the next clock cycle. In this case, we may need to slow down, or stall the pipeline. The work for branch computation may be mostly done during the EX stage, where the branch target address is computed, the source registers are compared by the ALU. Thus, the branch decision cannot be made until the end of the EX stage, however, we may need to know which instruction to fetch next, in order to keep the pipeline running. This leads to a control hazard. In order to handle this. We can either use stalls or implement branch prediction, which is pretty efficient in today's CPUs.

Or we can implement the branch a little earlier, during the ID phase instead of EX, where we can add a small comparsion circuit to the ID stage, after the source registers are read. Then we would only need to flush one instruction on a misprediction. Flushing introduces a single bubble, which is one cycle delay. 

### 意见








