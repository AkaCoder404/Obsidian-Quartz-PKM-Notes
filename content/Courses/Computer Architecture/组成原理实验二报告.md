# 实验2：计数器实验
## Results

![](https://s2.loli.net/2023/02/02/vzR5JXBW3tLQoV7.png)
## Environment
Windows in virtual machine on Mac M1. 

## Abstract
The goal of this experiment is to become familiar with the SystemVerilog HDL and the hiearchy of the thinpad_top architecture. It is also a good introduction to Vivado and basic process of hardware system development. It is a good review of the differences between combination logic and timing logic. 

## Experiment
Create a simple counter with a bit with of 4, and display it on a 7 segment display. 
- pressing `push_btn` will increase the counter by one
- pressing `reset_btn` will set counter to zro.
- after counting to 0xF, the counter will no longer increase
![](https://s2.loli.net/2023/02/02/ScH5fuibsekdNKZ.png)

First, set `lab2_top` to set as top. The hiearchical block deisgn in Vivado allow us to partition our block designs, or modules, into seperate functional groups. Thus, in this lab, our related components include `counter.sv`, `button_in.sv`, and `seg7_lut.sv`. Since the digital number display has already been defined, we simply have to set up our `counter.sv` and `button_in.sv` components. In order to view the synthesized design in Vivado, we go to `Synthesis menu > Open Synthesized Design > Schematic`
### Counter 模块
First we try to implement the asynchronous logic design (without a global unified clock-driven logical design). Our `counter.sv` module is declared is denoted as such, 

![](https://s2.loli.net/2023/02/02/ek4RlJSovX2WaCT.png)

The counter limit is quite simple, when it reaches `0xF`, and is continously pressed, it is set to itself. The it is declared in our `lab2_top.sv` as   

![](https://s2.loli.net/2023/02/02/rV1fdXgLCcmKjAx.png)

We declare a wire called count that connects counter module to the 7 segment digit display. We also declare a trigger wire that connects the button module describe below and the counter module.

### Button 模块
A synchronous design is a bit more complicated, but make it easier to debug timing problems in future complicated projects. In this case, the `Button_In` block module has one more function. If we use a synchronous logic, where we use `always_ff @(posedge clk)`, and a `push_button` signal to add one to our counter, then we have to consider the fact that the cycle span of a button press is way longer than the cycle time of one clock tick, if we simply set the trigger to respond to button press, then one button press will result in many triggers (since each cycle within the button press will trigger add to our counter), thus effectively increasing the count by a lot (immediately jump to 0xF), which is not what we want.  Thus, we have to add some logic such that the trigger only happens once during a button press. 

First we define `button_in.sv` module as
![](https://s2.loli.net/2023/02/02/fIHNtsWCVD59bQK.png)

We simply make sure that the triggler signal is sent only once per button press by adding condition statement that tracks whether or not the trigger has been activated within a button press time frame.

Then we use the module in `lab2_top.sv`

![](https://s2.loli.net/2023/02/02/S79xPsHQtc6vz1n.png)

### Display 模块
![](https://s2.loli.net/2023/02/02/FUgcT1NYwytLqBb.png)

Looking at the synthesis, we get
![](https://s2.loli.net/2023/02/02/gxrXcpDmtv2HMaG.png)
Which is very close to our wanted design.
Here is the edits for `lab2_top.sv`

## Conclusion
### Simulation
Using the `lab2_tb.sv` testbench file, we could simulate our design to see if it was working as intended. Using `Simulation > Run Behavior Simulation`, we see

![](https://s2.loli.net/2023/02/02/mxQ7iCBHkMndK1q.png)

And if we compare it to the values of the digital display
![](https://s2.loli.net/2023/02/02/lD759WymYrPn8zK.png)

We can see that our counter does indeed work. If we look more closely, 

![](https://s2.loli.net/2023/02/02/aSWRbVMjKu72kfg.png)

that indeed our "push_button" logic only triggers once everytime the button is pushed, even though the clock (clk_50M) cycles through many times before the button is released.  Also there is a delay of the up button. 

### 思考题
一，计数器模块中提到的异步逻辑与同步逻辑有何不同？可以通过观察 Vivado 综合后的电路原理图，并且查阅相关资料回答本题

If we keep the `button_in` module the same, we can compare the counter module designs schematics based on the design of the counter.  Using synchronous logic, our counter's design schemetic generated by vivado is shown below. 

![](https://s2.loli.net/2023/02/02/CmO5E8RGWKAUH9a.png)

In the synchronous counter, it is made up of 4 FDRE flip flops, and 4 LUTA flip flops. FDRE has an activate high clock enable (CE) and asynchronous active-high reset (R). R takes precendence over CE.  The R and CE inputs are examined in priority order during the low-to-high transition of the clock (C) input. If R is asserted, Q is set to 0. Otherwise, if CE is asserted, Q is loaded with the data on the D input. Otherwise, Q retains its previous value.

Compared to it, the code of our asynchronous logic of our counter is (one found in the documentation)
![](https://s2.loli.net/2023/02/02/lz15rxJDt7oEWXk.png)

Its synthesized schematic is 
![](https://s2.loli.net/2023/02/02/gt5zBElvOX8kZfw.png)
In this counter, we see four FDCE, which is defined as a flip flop with clock enable and asynchronous clear. The logic is as follows, 
- When clock enable (CE) is High and asynchronous clear (CLR) is not asserted, the data on the data input (D) of this design element is transferred to the corresponding data output (Q) during the clock (C) transition.
- When CLR is active, it overrides all other inputs and resets the data output (Q) Low.
- When CE is Low, clock transitions are ignored.

We see that CE inputs are grounded, and thus clock transitions are ignored, and thus is not an synchronous design (it does not rely on clock signals).

Looking at the simulation,
![](https://s2.loli.net/2023/02/02/vlsJGpTEDcdtx7M.png)

We can see that there is less delay after pressing `push_btn` compared to the synchronous design, the display/counter increments on the first rising edge of the clock after the button press, while in the synchronous design simulation, the display/counter changes on the second rising clock after the button press. 

This delay could be further reduced if even removed the `button` module, and directly ohave counter respond to a button press.

### Summary
This experiment was a great introduction to vivado and a good review of hardware description logic and thinking of it as hardware design, not simple coding, where everything occurs sequentially. 